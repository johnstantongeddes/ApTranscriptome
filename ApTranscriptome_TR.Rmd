Thermal reactionome of the common ant species *Aphaenogaster*
================================================================
   
**Author:** [John Stanton-Geddes](john.stantongeddes.research@gmail.com)

**March 20, 2014**

**Technical Report No. 3**

**Department of Biology**

**University of Vermont**

```{r setup, echo=FALSE, results='hide', message = FALSE}
# Global settings
options(stringsAsFactors=FALSE)

# Load libraries
library(R.utils)
library(ggplot2)
library(knitr)
library(knitcitations)
library(pander)
library(stringr)
library(data.table)
library(RCurl)
library(plyr)

# Load Bioconductor libraries
#source("http://bioconductor.org/biocLite.R")
#biocLite("topGO")
#biocLite("Rgraphviz")
library(topGO) 
suppressMessages(library(Rgraphviz))

# load custom functions
source("scripts/RxNseq.R")

# knitr options
opts_chunk$set(cache=TRUE)

# directory to save results
resultsdir <- "results/"
```


## Summary ##
  
In this technical report, which accompanies the manuscript **Thermal reactionome of a common ant species** (Stanton-Geddes et al., in press), we:

1. describe the *de novo* assembly of the transcriptome for two ant colonies with in the *Aphaenogaster rudis-picea-fulva* species complex `r citep("10.1155/2012/752815")`
2. identify thermally-responsive genes
3. perform gene set enrichment analysis

This script is completely reproducible assuming that R, `knitr` and the other required libraries (listed within the source document) are installed on a standard linux system using the following:
    
    Rscript -e "library(knitr); knit('ApTranscriptome_TR.Rmd')"

The assembled transcriptome, annotation and expression values are downloaded rather than re-run due to the computational demands, but the exact commands for each of these steps are documented below.



## Data ##

The Illumina fastq files are available from [https://minilims1.uvm.edu/BCProject-26-Cahan/downloads.html]. The Trimmomatic filtered fastq files should be downloaded, uncompressed and moved to the appropriate directory using the following code.

~~~
# download filtered fastq files, uncompress and move
wget --no-check-certificate https://minilims1.uvm.edu/BCProject-26-Cahan/_downloads/trimmomatic_output.tar.gz
tar -zxvf trimmomatic_output.tar.gz
mkdir -p data/
mv ind_files data/.
~~~



## Sample description ##

Two ant colonies were used for the transcriptome sequencing. The first, designated A22, was collected at Molly Bog, Vermont in August 2012 by Nick Gotelli and Andrew Nguyen. This colony was putatively identifed as *A. picea*. The second colony, designated Ar, was collected by Lauren Nichols in Raleigh, North Carolina. These colonies were maintained in the lab for 6 months prior to sample collection. 

For each colony, three ants were exposed to one of 12 temperature treatments, every 3.5C ranging from 0C to 38.5C, for one hour in glass tubes in a water bath. The ants were flash frozen and stored at -80C until RNA was extracted using a two step extraction; [RNAzol RT](http://www.mrcgene.com/rnazol.htm) (Molecular Research Center, Inc) followed by an [RNeasy Micro](http://www.qiagen.com/products/catalog/sample-technologies/rna-sample-technologies/total-rna/rneasy-micro-kit) column (Qiagen). Samples from each colony were pooled and sequenced in separate lanes on a 100bp paired-end run of an Illumina HiSeq at the University of Minnesota Genomics Center, yielding 20e6 and 16e6 reads for the A22 and Ar samples, respectively.



## Transcriptome assembly ##

The Illumina reads were filtered using the program [Trimmomatic](http://www.usadellab.org/cms/?page=trimmomatic) `r citep("10.1093/nar/gks540")` to remove Ilumina adapter sequences and filter out bases with quality scores less than ??. 

~~~
TRIMMOMATIC CODE
~~~

This filtering yielded...

These reads were combined and used in *de novo* transcriptome assembly using the program [Trinity](http://trinityrnaseq.sourceforge.net/) `r citep("10.1038/nbt.1883")`. Note that this required ??? GB RAM and ??? hours run-time and was run on the [Vermont Genetics Network](http://vgn.uvm.edu/) computing cluster. 

~~~
TRINITY CODE
~~~

This assembly contained 100,381 unique components (roughly genes) in 126,172 total transcripts (Table 1). 

As we were assembling two divergent colonies into a single transcriptome, we suspected that this assembly would be susceptible to known problems of errors during assembly (e.g. chimeric transcripts that are fusions of two transcripts) and redundancy `r citep("10.1186/1471-2164-14-328")`. To account for this, we performed two post-assembly processing steps.

First, we ran the program [cap3](http://seq.cs.iastate.edu/) `r citep("10.1101/gr.9.9.868")` setting the maximum gap length and band expansion size to 50 `-f 50 -a 50`, no end clipping as the reads were already filtered `k 0`, requiring 90% identity for assembly, and a minimum overlap length of 100 bp `-o 100`. The percent identity threshold of 90% was chosen to liberally collapse orthologous contigs from the two colonies that may have been assembled separately. 

    cap3 Trinity.fasta -f 50 -a 50 -k 0 -p 90 -o 100 > Trinity_cap3.out

The output of `cap3` gives assembled "contigs" and unassembled "singlets" that were concatenated into a single file.

    # check the number of contigs clustered
    grep -c "Contig" Trinity.fasta.cap.contigs
    grep -c "comp" Trinity.fasta.cap.singlets
    # compare to contigs from Trinity output
    grep -c "comp" Trinity.fasta

    # Combine contigs and singlets from CAP3
    cat Trinity.fasta.cap.contigs Trinity.fasta.cap.singlets > Trinity_cap3.fasta

The output file "Trinity.fasta.cap.info" gives specific information on which contigs were collapsed.

Subsequent to running `cap3`, we ran [uclust](http://drive5.com/usearch/manual/uclust_algo.html) to cluster sequences completely contained within longer sequences, again specificing a 90% identity cutoff for clustering. 

    # sort
    uclust --sort Trinity_cap3.fasta --output Trinity_cap3_sorted.fasta
    # cluster by 90% similarity threshold
    uclust --input Trinity_cap3_sorted.fasta --uc Trinity_cap3_uclust.out --id 0.90
    # convert uclust to fasta format
    uclust --uc2fasta Trinity_cap3_uclust.out --input Trinity_cap3_uclust.fasta

These post-processing step removed `r round((126172-105536)/126172 * 100, 0)`% of the initial reads (Table 1).

```{r assemstats, results = "asis", echo=FALSE}
# make table
trinity <- c("126,172", "100,389,539", "358", "795", "16,201", "1,631")
reduced <- c("105,536", "62,648,997", "320", "593", "15,491", "895")

assemstats <- rbind(trinity, reduced)
colnames(assemstats) <- c("Total contigs", "Total length", "Median contig size", "Mean contig size", "N50 contig", "N50 Length")

pandoc.table(assemstats, style="rmarkdown", caption = "Statistics for Trinity and cap3+uclust reduced transcriptome assemblies")
```

Running Trinity is time and computationally-intensive, so the final filtered assembly can be downloaded from [http://johnstantongeddes.org/assets/files/Trinity_filtered_assembly.tgz] 

~~~
# download filtered Trinity assembly, uncompress and move
wget http://johnstantongeddes.org/assets/files/Trinity_filtered_assembly.tgz
tar -zxvf trimmomatic_output.tar.gz
mkdir -p results/
mkdir -p results/trinity-full/
mv Trinity_cap3_uclust.fasta /results/trinity-full/.
~~~



## Transcriptome annotation ##

Annotation was performed by uploading the reduced assembly "Trinity_cap3_uclust.fasta" to the web-based annotation program [FastAnnotator](http://fastannotator.cgu.edu.tw/index.php) `r citep("10.1186/1471-2164-13-S7-S9")`.

#Results are available as job ID [13894410176993](http://fastannotator.cgu.edu.tw/job.php?jobid=13894410176993#page=basicinfo).

This annotation file can be read directly to R:

```{r download, echo = TRUE, results = "hide"}
### Annotation file
# from either AWS or GoogleDrive
annotationURL <- getURL("http://johnstantongeddes.org/assets/files/Aphaeno_transcriptome_AnnotationTable.txt")
#a2 <- getURL("https://googledrive.com/host/0B75IymziRJ_9Tlg1U1Vxbjk1bzg") # GoogleDrive link

annotationfile <- read.csv(textConnection(annotationURL), header = TRUE, sep = "\t", stringsAsFactors = FALSE)
str(annotationfile)

# Convert to data.table
annotationtable <- data.table(annotationfile)
head(annotationtable)
```

Transcriptome annotations are nearly impossible to visualize in a meaningful way. For lack of better ideas, I made a word cloud:

```{r wordcloud, cache=TRUE, eval=FALSE}
library(tm)
library(wordcloud)
library(RColorBrewer)
library(stringr)

# subset and extract unique best hits to NCBI nr database
ann <- unique(annotationfile$best.hit.to.nr)
annsplit <- str_split_fixed(ann, pattern = " ", n=2)
annvec <- annsplit[,2]

# create Corpus of terms. convert to dataframe for plotting wordcloud
ap.corpus <- Corpus(VectorSource(annvec))
ap.corpus <- tm_map(ap.corpus, removePunctuation)
ap.corpus <- tm_map(ap.corpus, tolower)
ap.corpus <- tm_map(ap.corpus, function(x) removeWords(x, stopwords("english")))
tdm <- TermDocumentMatrix(ap.corpus)
m <- as.matrix(tdm)
v <- sort(rowSums(m),decreasing=TRUE)
d <- data.frame(word = names(v),freq=v)
pal <- brewer.pal(4, "Dark2")
pal <- pal[-(1:2)]

#png(paste(resultsdir, "wordcloud.png", sep=""), width=1280,height=800)
wordcloud(d$word,d$freq, scale=c(8,.3),min.freq=2,max.words=100, random.order=T, rot.per=.15, colors=pal, vfont=c("sans serif","plain"))
#dev.off()
```

This wordcloud shows that we do not know much about the transcriptome - mostly hypothetical or predicted proteins. I removed these uninformative words and generated a new wordcloud. 

```{r wordcloud2, cache=TRUE}
# remove 'protein', 'predicted' and 'hypothetical'
rmwords <- c("hypothetical", "protein", "isoform", "subunit", "family", "putative", "partial", "domain", "containing", "predicted", "domaincontaining", "uncharacterized")
ap.corpus.rmwords <- tm_map(ap.corpus, removeWords, rmwords)
tdm <- TermDocumentMatrix(ap.corpus.rmwords)
m <- as.matrix(tdm)
v <- sort(rowSums(m),decreasing=TRUE)
d <- data.frame(word = names(v),freq=v)
pal <- brewer.pal(8, "Dark2")
pal <- pal[-(1:2)]
#png(paste(resultsdir, "wordcloud2.png", sep=""), width=1280,height=800)
wordcloud(d$word,d$freq, scale=c(8,.3),min.freq=2,max.words=100, random.order=T, rot.per=.15, colors=pal, vfont=c("sans serif","plain"))
#dev.off()
```
                                                 
                                                
## Identification of thermally-responsive genes ##

### Quantify gene expression ###

I quantified gene expression using [sailfish](http://www.cs.cmu.edu/~ckingsf/software/sailfish/index.html). To run this program, first make sure that PATHs to the software libraries are set up correctly: 
                                                 
    export LD_LIBRARY_PATH=/opt/software/Sailfish-0.6.2-Linux_x86-64/lib:$LD_LIBRARY_PATH
    export PATH=/opt/software/Sailfish-0.6.2-Linux_x86-64/bin:$PATH

Then build the index of the assembly:

    sailfish index -t Trinity_cap3_uclust.fasta -o sailfish-index -k 20 -p 4

Once this is done, quantify expression for the Trimmomatic filtered reads from each colony-treatment sample separately. Note that for each sample, there are three four filtered read files:

- paired.left.fastq
- paired.right.fastq
- unpaired.left.fastq
- unpaired.right.fastq
                                                 
Make a directory for the expression values

    mkdir sailfish-expression                                                 

Then, for each sample, run the following command:
                                                 
    sailfish -i sailfish-index -o sailfish-expression/A22-0 --reads A22-0_ATCACG.paired.left.fastq A22-0_ATCACG.paired.right.fastq A22-0_ATCACG.unpaired.left.fastq A22-0_ATCACG.unpaired.right.fastq -p 4

Or, using a loop in R:                                                 
                                                 
```{r sailfish, eval=TRUE, echo=TRUE, cache=TRUE}
# directory containing trimmed reads
readdir <- "data/ind_files/" 
# sailfish index directory
sfindex <- "results/trinity-full/sailfish-index"
# sailfish expression directory
sfexpressionroot <- "results/trinity-full/sailfish-expression/"

# list of reads in each of four trimmed classes
readlist <- list.files(readdir)
(paired.left <- readlist[grep(".\\.paired.left.fastq$", readlist)])
(paired.right <- readlist[grep("\\.paired.right.fastq$", readlist)])
(unpaired.left <- readlist[grep("unpaired.left.fastq$", readlist)])
(unpaired.right <- readlist[grep("unpaired.right.fastq$", readlist)])

# Loop across each sample and quantify expression

# NOTE - samples listed in same order as given by the above lists
samples <- c("A22-0", "A22-10", "A22-14", "A22-17", "A22-21", "A22-24", "A22-28", "A22-31", "A22-35", "A22-38", "A22-3", "A22-7", "Ar-0", "Ar-10", "Ar-14", "Ar-17", "Ar-21", "Ar-24", "Ar-28", "Ar-31", "Ar-35", "Ar-38", "Ar-3", "Ar-7")

for (j in 1:length(samples)) {
    message("Start expression quantification for sample ", samples[j], ": ", Sys.time())
    quantdir <- paste(sfexpressionroot, samples[j], "_quant", sep="")
    samp.pos <- grep(paste(paste(samples[j], "_", sep="")), paired.left)
    samp.paired.l <- paste(readdir, paired.left[samp.pos], sep="")
    samp.paired.r <- paste(readdir, paired.right[samp.pos], sep="")
    samp.unpaired.l <- paste(readdir, unpaired.left[samp.pos], sep="")
    samp.unpaired.r <- paste(readdir, unpaired.right[samp.pos], sep="")
    sailfishcmd <- paste("sailfish quant -i ", sfindex, " -o ", quantdir, " --reads ", samp.paired.l, " ", samp.paired.r, " ", samp.unpaired.l, " ", samp.unpaired.r, " -p 4", sep="")
#   print(sailfishcmd)
    system(sailfishcmd)
    message("Done with expression quantification for sample ", samples[j], ": ", Sys.time(), "\n")
}
```

This generated a directory for each sample

`r list.files(sfexpressionroot)`

and within each directory there are the following r:

`r list.files(quantdir)`

The file *quant_bias_corrected.sf* contains the following columns, following a number of header lines:

1. Transcript ID
2. Transcript Length
3. Transcripts per Million (TPM): computed as described in `r citep("10.1093/bioinformatics/btp692")`, and is meant as an estimate of the number of transcripts, per million observed transcripts, originating from each isoform.
4. Reads Per Kilobase per Million mapped reads (RPKM): classic measure of relative transcript abundance, and is an estimate of the number of reads per kilobase of transcript (per million mapped reads) originating from each transcript.

The TPM column for each sample was extracted and combined into a matrix for each colony.

```{r load_expression_data, eval=TRUE, echo=FALSE, results='hide'}
# read in each file using loop
samples <- c("A22-0", "A22-3", "A22-7", "A22-10", "A22-14", "A22-17", "A22-21", "A22-24", "A22-28", "A22-31", "A22-35", "A22-38", "Ar-0", "Ar-3", "Ar-7", "Ar-10", "Ar-14", "Ar-17", "Ar-21", "Ar-24", "Ar-28", "Ar-31", "Ar-35", "Ar-38")

for (j in 1:length(samples)) {
    samp <- samples[j]
    trtval <- as.numeric(str_split_fixed(samp, "-", 2)[2])
    outpre <- gsub("-", "_", samp)
    outname <- paste(outpre, "_quant", sep="")
    read.sailfish.quant(filein=paste(sfexpressionroot, samp, "_quant/quant_bias_corrected.sf", sep=""), outname=outname, samp = samp, trtval = trtval)
}

# combine into long format
A22.TPM <- rbind(A22_0_quant, A22_3_quant, A22_7_quant, A22_10_quant, A22_14_quant, A22_17_quant, A22_21_quant, A22_24_quant, A22_28_quant, A22_31_quant, A22_35_quant, A22_38_quant)
str(A22.TPM)

# convert to data.table
A22.TPM <- data.table(A22.TPM)
setkey(A22.TPM, Transcript, val)

# set "trt" to true values - truncated in file names for convenience

A22.TPM[val==3,val:=3.5]
A22.TPM[val==10,val:=10.5]
A22.TPM[val==17,val:=17.5]
A22.TPM[val==24,val:=24.5]
A22.TPM[val==31,val:=31.5]
A22.TPM[val==38,val:=38.5]
head(A22.TPM)
str(A22.TPM)


# Repeat for Ar
Ar.TPM <- rbind(Ar_0_quant, Ar_3_quant, Ar_7_quant, Ar_10_quant, Ar_14_quant, Ar_17_quant, Ar_21_quant, Ar_24_quant, Ar_28_quant, Ar_31_quant, Ar_35_quant, Ar_38_quant)
Ar.TPM <- data.table(Ar.TPM)
setkey(Ar.TPM, Transcript, val)
Ar.TPM[val==3,val:=3.5]
Ar.TPM[val==10,val:=10.5]
Ar.TPM[val==17,val:=17.5]
Ar.TPM[val==24,val:=24.5]
Ar.TPM[val==31,val:=31.5]
Ar.TPM[val==38,val:=38.5]
head(Ar.TPM)
str(Ar.TPM)

tables()
```

Note that expression levels at each temperature treatment are highly correlated between the two colonies.

```{r exp_correlations, echo=FALSE, results='asis'}
# Make Rmarkdown pandoc table of correlations among expression levels between colonies at each temp

temp <- c(0, 3.5, 7, 10.5, 14, 17.5, 21, 24.5, 28, 31.5, 35, 38.5)
cors <- c(round(cor(Ar_0_quant$TPM, A22_0_quant$TPM), 2), round(cor(Ar_3_quant$TPM, A22_3_quant$TPM), 2), round(cor(Ar_7_quant$TPM, A22_7_quant$TPM), 2), round(cor(Ar_10_quant$TPM, A22_10_quant$TPM), 2), round(cor(Ar_14_quant$TPM, A22_14_quant$TPM), 2), round(cor(Ar_17_quant$TPM, A22_17_quant$TPM), 2), round(cor(Ar_21_quant$TPM, A22_21_quant$TPM), 2), round(cor(Ar_24_quant$TPM, A22_24_quant$TPM), 2), round(cor(Ar_28_quant$TPM, A22_28_quant$TPM), 2), round(cor(Ar_31_quant$TPM, A22_31_quant$TPM), 2), round(cor(Ar_35_quant$TPM, A22_35_quant$TPM), 2), round(cor(Ar_38_quant$TPM, A22_38_quant$TPM), 2))

cortable <- cbind(temp, cors)

pandoc.table(cortable, style="rmarkdown", caption = "correlations between colonies at each temperature treatment")
```

## Identification of thermally-responsive genes

To identify transcripts (roughly equivalent to genes) that show thermal responsiveness, I fit the following linear model to each transcript:

$$ TPM = \beta_0 + \beta_1(colony) + \beta_2(temp) + \beta_3(temp^2) + \beta_4(colony * temp) + \\beta_5(colony * temp^2) + \epsilon $$

where TPM is transcripts per million. 



**Preliminary [examination](https://minilims1.uvm.edu/BCProject-26-Cahan/methods.html#clustering-of-samples) of the data indicated that the A22_7 and Ar_7 samples may have been switched, so I remove these values from the analysis.** 

```{r RxN, echo=TRUE, eval=TRUE, cache=TRUE}
A22.TPM[,colony:="A22"]
Ar.TPM[,colony:="Ar"]
TPM.dt <- rbind(A22.TPM, Ar.TPM)
TPM.dt$colony <- as.factor(TPM.dt$colony)
str(TPM.dt)

setkey(TPM.dt, val)
TPM.dt.sub <- TPM.dt[val != 7] 
unique(TPM.dt.sub$val)

# define model for RxN function
model <- "TPM ~ colony + val + I(val^2) + colony:val + colony:I(val^2)"

# identify responsive transcripts
RxNout <- RxNseq(f = TPM.dt.sub, model = model, threshold = 0.05)

# outliers may influence results. test for this by fitting with response log(TPM+1)
modellog <-  "log(TPM+1) ~ colony + val + I(val^2) + colony:val + colony:I(val^2)"
RxNout.log <- RxNseq(f = TPM.dt.sub, model = modellog, threshold = 0.05)


save.image("RxN_combined_results.RData")
```

Of the `r nrow(RxNout)` transcripts, `r length(which(RxNout$pval < 0.05))` have models with P < 0.05.

Many of these are likely false positives, so I adjusted P-values using false discovery rate (FDR) to identify only those transcripts with less than 5% FDR as significant. 

```{r fdr}
RxNout$padj <- p.adjust(RxNout$pval, method = "fdr")
# Plot FDR values against initial pvalues
par(mfrow = c(2,1))
hist(RxNout$pval)
hist(RxNout$padj)

# subset to significant transcripts
signif.transcripts <- RxNout[which(RxNout$padj < 0.05), ]
```

## Functional annotation ##

In the previous section, I identified transcripts that show significant responses in expression. Next, I add gene annotation and ontology information to these transcripts.  

```{r annotation}
# add annotation information
setkey(annotationtable, Sequence.Name)
signif.transcripts <- data.table(signif.transcripts)
setkey(signif.transcripts, Transcript)
signif.transcripts <- annotationtable[signif.transcripts]
setnames(signif.transcripts, "Sequence.Name", "Transcript")
```


## Thermally-responsive transcripts

The set of transcripts with significant expression patterns include those with expression that differs by colony, temperature and the interaction of colony and temperature. In this section, I am specifically interested in the thermally-responsive transcripts (temperature and colony x temperature) so I subset the significant transcripts to examine these. 

```{r responsive_transcripts}
# transcripts that differ in expression by colony only
colony.transcripts <- signif.transcripts[!is.na(signif.transcripts$'coef.colony') & is.na(signif.transcripts$'coef.val') & is.na(signif.transcripts$'coef.I(val^2)') & is.na(signif.transcripts$'coef.colony:val') & is.na(signif.transcripts$'coef.colony:I(val^2)')]
# check that subset correct - no transcripts with significant temperature terms
length(which(!is.na(colony.transcripts$'coef.val') | !is.na(colony.transcripts$'coef.I(val^2)') | !is.na(colony.transcripts$'coef.colony:val') | !is.na(colony.transcripts$'coef.I(val^2)')))
str(colony.transcripts)
# order by adjusted P-value
colony.transcripts <- colony.transcripts[order(colony.transcripts$padj), ]

# remaining transcripts are thermally responsive
responsive.transcripts <- signif.transcripts[!is.na(signif.transcripts$'coef.val') | !is.na(signif.transcripts$'coef.I(val^2)') | !is.na(signif.transcripts$'coef.colony:val') | !is.na(signif.transcripts$'coef.colony:I(val^2)')]
dim(responsive.transcripts)

# check that these two groups sum to total significant transcripts
stopifnot(all.equal(nrow(signif.transcripts), nrow(colony.transcripts) + nrow(responsive.transcripts)))

# split responsive_transcripts into those that have same temperature response in both colonies and 
# main effect of temperature only
temperature.transcripts <- responsive.transcripts[is.na(responsive.transcripts$'coef.colony:val') & is.na(responsive.transcripts$'coef.colony:I(val^2)')]
# order by adjusted P-value
temperature.transcripts <- temperature.transcripts[order(temperature.transcripts$padj), ]
str(temperature.transcripts)

# transcripts that have colony x temperature interaction
interaction.transcripts <- signif.transcripts[!is.na(signif.transcripts$'coef.colony:val') | !is.na(signif.transcripts$'coef.colony:I(val^2)')]
# order by adjusted P-value
interaction.transcripts <- interaction.transcripts[order(interaction.transcripts$padj), ]
str(interaction.transcripts)

# check that these two groups sum to total responsive transcripts
stopifnot(all.equal(nrow(responsive.transcripts), nrow(temperature.transcripts) + nrow(interaction.transcripts)))
```

```{r table_results, echo=FALSE, results='asis'}
clist <- c('Total', 'Colony', 'Temperature', 'Temperature:Colony')
siglist <- c(nrow(signif.transcripts),
             nrow(colony.transcripts),
             nrow(temperature.transcripts),
             nrow(interaction.transcripts)
             )

sigtable <- data.frame(Coefficient = clist, "Number significant" = siglist)

pandoc.table(sigtable, style="rmarkdown", caption = "Number of transcripts (of 105,536 total) at 5% FDR with expression that depends on colony, temperature or their interaction.")
```

Table 3 shows that `r round((nrow(temperature.transcripts) + nrow(interaction.transcripts))/nrow(signif.transcripts), 2)*100`% of the significant transcripts are thermally-responsive, with `r round(nrow(interaction.transcripts)/(nrow(temperature.transcripts) + nrow(interaction.transcripts)), 2)*100`% of these transcripts having a thermal-response that differs by colony.


I perform gene set enrichment analysis below, but a quick `grep` shows that there are 26 transcripts with GO term "response to stress", though this is not enriched compared to the frequency of this term in the full dataset.
  
```{r GO_contingency_test}
# GO 'response to stress' hits in responsive transcripts
responsive.transcripts[grep("GO:0006950", responsive.transcripts$GO.Biological.Process), list(Transcript, best.hit.to.nr)]

resp.stress.responsive.count <- nrow(responsive.transcripts[grep("GO:0006950", responsive.transcripts$GO.Biological.Process), list(Transcript, best.hit.to.nr)])
# GO 'response to stress' hits in all transcripts
resp.stress.all.count <- nrow(annotationtable[grep("GO:0006950", annotationtable$GO.Biological.Process), list(Sequence.Name, best.hit.to.nr)])

GO.stress.table <- matrix(rbind(resp.stress.responsive.count, nrow(responsive.transcripts) - resp.stress.responsive.count, resp.stress.all.count, nrow(annotationtable) - resp.stress.all.count), nrow = 2)

GO.stress.Xsq <- chisq.test(GO.stress.table)
GO.stress.Xsq
```

There are also 4 heat shock related genes in the responsive transcripts, out of 130 total.

```{r grep_shock}
hsp_responsive <- responsive.transcripts[grep("shock", responsive.transcripts$best.hit.to.nr), list(Transcript, best.hit.to.nr)]
nrow(hsp_responsive)

hsp_all <- annotationtable[grep("shock", annotationtable$best.hit.to.nr), list(Sequence.Name, best.hit.to.nr)]
nrow(hsp_all)
```


### Thermal-response functional types ###

The previous section simply identified the transcripts with thermally-responsive expression. In this section, I determine the shape of the expression response to temperature for each transcript. Categories of expression response are:

* High - increase expression with temperature
* Low - decrease expression with temperature
* Intermediate - maximum expression at intermediate temperatures (14 - 28C)
* Bimodal - expressed greater than two standard deviations of expression at both low and high temperatures

I do this first for the thermally-responsive transcripts where there is no interaction with colony. For the transcripts where thermal-responsive expression depends on colony, I determine the functional type of the expression response separately for each colony. 



```{r expression_shape, eval=TRUE, echo=TRUE}
# merge RxN results with expression values
temperature.transcripts.TPM <- TPM.dt.sub[temperature.transcripts]

# apply the 'RxNply' function to determine maximum and minimum temperatures of expression, as well as the expression level at the optimum temperature of 19.25C
temperature.transcripts.type <- ddply(temperature.transcripts.TPM, .(Transcript), RxNply)
temperature.transcripts.type$max.val <- as.numeric(temperature.transcripts.type$max.val)
temperature.transcripts.type$min.val <- as.numeric(temperature.transcripts.type$min.val)
temperature.transcripts.type$opt.exp <- as.numeric(temperature.transcripts.type$opt.exp)
temperature.transcripts.type$exp_type <- as.factor(temperature.transcripts.type$exp_type)

# repeat for transcripts that have an interaction with colongy
# A22
A22.interaction.transcripts.type <- ddply(interaction.transcripts.TPM["A22"], .(Transcript), RxNply)
A22.interaction.transcripts.type$max.val <- as.numeric(A22.interaction.transcripts.type$max.val)
A22.interaction.transcripts.type$min.val <- as.numeric(A22.interaction.transcripts.type$min.val)
A22.interaction.transcripts.type$opt.exp <- as.numeric(A22.interaction.transcripts.type$opt.exp)
A22.interaction.transcripts.type$exp_type <- as.factor(A22.interaction.transcripts.type$exp_type)
str(A22.interaction.transcripts.type)

# Ar
Ar.interaction.transcripts.type <- ddply(interaction.transcripts.TPM["Ar"], .(Transcript), RxNply)
Ar.interaction.transcripts.type$max.val <- as.numeric(Ar.interaction.transcripts.type$max.val)
Ar.interaction.transcripts.type$min.val <- as.numeric(Ar.interaction.transcripts.type$min.val)
Ar.interaction.transcripts.type$opt.exp <- as.numeric(Ar.interaction.transcripts.type$opt.exp)
Ar.interaction.transcripts.type$exp_type <- as.factor(Ar.interaction.transcripts.type$exp_type)
str(Ar.interaction.transcripts.type)

# combine into single data.table
A22.interaction.transcripts.type$colony <- "A22"
Ar.interaction.transcripts.type$colony <- "Ar"
# first copy of temperature.transcripts.type as colony A22
temperature.transcripts.type$colony <- "A22"
# combine
responsive.transcripts.type <- rbind(A22.interaction.transcripts.type, Ar.interaction.transcripts.type, temperature.transcripts.type)
# add second copy of temperature.transcripts.type as colony Ar
temperature.transcripts.type$colony <- "Ar"
responsive.transcripts.type <- rbind(responsive.transcripts.type, temperature.transcripts.type)
responsive.transcripts.type$colony <- as.factor(responsive.transcripts.type$colony)
str(responsive.transcripts.type)
```


```{r expression_exp_type_table, eval=TRUE, echo=FALSE, results='asis'}
# table type of response
A22.type.table <- table(responsive.transcripts.type[responsive.transcripts.type$colony == "A22", 'exp_type'])
Ar.type.table <- table(responsive.transcripts.type[responsive.transcripts.type$colony == "Ar", 'exp_type'])

exp_type.table <- rbind(A22.type.table, Ar.type.table)
rownames(exp_type.table) <- c("A22", "Ar")

pandoc.table(exp_type.table, style="rmarkdown", caption = "Number of transcripts with maximum expression at high, low, intermediate or both high and low (bimodal) temperatures.")
```

Table 4 shows the number of transcripts that fall into each expression type for each each colony. The totals for each colony include the `r nrow(temperature.transcripts)` transcripts that have consistent temperature responses between the two colonies. 


## Shiny interactive web-app

To assist visualization of specific transcripts, I made a interactive web-app using the [shiny](http://www.rstudio.com/shiny/) package. The scripts for this app are in the sub-directory `.\ApRxN-shinyapp`.

Export data for interactive shiny app. 

```{r shiny_file}
# scale expression values 
responsive.transcripts.TPM <- TPM.dt.sub[responsive.transcripts]
responsive.transcripts.TPM[,exp.scaled:=scale(TPM), by = Transcript]
str(responsive.transcripts.TPM)
write.csv(responsive.transcripts.TPM, file = "ApRxN-shinyapp/responsive.transcripts.TPM.csv", quote = TRUE, row.names = FALSE)
```


## Colony-level comparison ##

In this section, I examine differences in thermal reaction norms of transcripts between *Ar* and *A22* using the categories as defined by `r citep("10.1086/675302")`:

- *Offset, O*: overall difference in the mean expression value across all temperatures
- *Slope, S*: difference in overall slope
- *Curvature, C*: average difference in curvature of the reaction norm
- *Wiggle, W*: variability in shape not captured by the previous three measures

```{r offset, echo=TRUE, eval=TRUE}
testset <- TPM.dt.sub[1:220, ]
testoffset <- ddply(testset, .(colony, Transcript), summarise, offset = mean(TPM))
A22meanTPM <- ddply(TPM.dt.sub, .(colony, Transcript), summarise, meanTPM = mean(TPM))

```







### Plasticity versus constitutive expression

Compare the expression levels at optimum (19.25C) between the two colonies for genes in each expression group. Specifically, are genes that are upregulated at high temperatures in A22 more highly expressed at 21C in Ar? Conversely, are genes that are upregulated at low temps more highly expressed at 21C in A22? 

```{r optimum_expression_comparison, cache=TRUE, eval=FALSE}
# list of transcripts that are 'high' expressed in A22
A22_high_transcripts <- responsive.transcripts.type[which(responsive.transcripts.type$colony == "A22" & responsive.transcripts.type$exp_type == "High"), "Transcript"]
# dataframe of transcripts from both colonies that are 'high' expressed in A22
A22_high_df <- responsive.transcripts.type[which(responsive.transcripts.type$Transcript %in% A22_high_transcripts), ]

# Compare expression at optimum temp (19.25C) between colonies using t-test
A22_high_df$colony <- as.factor(A22_high_df$colony)
boxplot(data = A22_high_df, opt.exp ~ colony)
boxplot(data = A22_high_df, log(opt.exp+10) ~ colony)
t.test(A22_high_df[which(A22_high_df$colony == "Ar"), "opt.exp"],  A22_high_df[which(A22_high_df$colony == "A22"), "opt.exp"])

# remove outlier transcripts
A22_high_df_out <- A22_high_df[-which(A22_high_df$opt.exp > 1000), ]
t.test(A22_high_df_out[which(A22_high_df_out$colony == "Ar"), "opt.exp"],  A22_high_df_out[which(A22_high_df_out$colony == "A22"), "opt.exp"])
```

The `t.test` fails to account for the many orders of magnitude difference in expression among transcripts, e.g. non-equal variances. This problem is the key issue in the analysis of differential expression `r citep(c("10.1186/1471-2105-11-94", "10.1038/nprot.2013.099")`. As my goal is simply to determine if expression is typically greater at 19.25C in *Ar* than *A22* for genes that are up-regulated at high temperatures in *A22*, I use a non-parametric Wilcoxon signed rank-test

```{r A22_high_wilcoxon}
wilcox.test(A22_high_df[which(A22_high_df$colony == "A22"), "opt.exp"],  A22_high_df[which(A22_high_df$colony == "Ar"), "opt.exp"], alternative = "two.sided", paired = TRUE, conf.int = TRUE)
```

Yes - transcripts that are up-regulated at high temperatures in *A22* are more highly-expressed at 19.25C in *Ar*. Note that A22 had the larger library size so if this was due to TPM not correctly accounting for differences in reads between samples, we would expect to see a positive instead of negative value here.

Next I test the converse, that transcripts that are up-regulated at low temperatures in *Ar* are more highly-expressed at 19.25C temperatures in *A22*. 

```{r Ar_low_wilcoxon}
# list of transcripts that are 'Low' expressed in Ar
Ar_low_transcripts <- responsive.transcripts.type[which(responsive.transcripts.type$colony == "Ar" & responsive.transcripts.type$exp_type == "Low"), "Transcript"]
# dataframe of transcripts from both colonies that are 'Low' expressed in Ar
Ar_low_df <- responsive.transcripts.type[which(responsive.transcripts.type$Transcript %in% Ar_low_transcripts), ]
dim(Ar_low_df)

# boxplots
boxplot(data = Ar_low_df, opt.exp ~ colony)
boxplot(data = Ar_low_df, log(opt.exp+1) ~ colony)

# Wilcoxon signed rank-test
wilcox.test(Ar_low_df[which(Ar_low_df$colony == "A22"), "opt.exp"],  Ar_low_df[which(Ar_low_df$colony == "Ar"), "opt.exp"], alternative = "two.sided", paired = TRUE, conf.int = TRUE)
```

No difference in transcript expression at 19.25C between colonies for transcripts that are up-regulated at low temperatures in *Ar*. 

To confirm that there are not sample-level issues, I performed the same comparison using transcripts where I do *not* expect to see a difference in expression.

```{r intermediate_transcripts}
# list of transcripts that are 'Intermediate' expressed in A22
A22_int_transcripts <- responsive.transcripts.type[which(responsive.transcripts.type$colony == "A22" & responsive.transcripts.type$exp_type == "Intermediate"), "Transcript"]
A22_int_df <- responsive.transcripts.type[which(responsive.transcripts.type$Transcript %in% A22_int_transcripts), ]
A22_int_df$colony <- as.factor(A22_int_df$colony)

# Wilcoxon signed rank-test
wilcox.test(A22_int_df[which(A22_int_df$colony == "A22"), "opt.exp"],  A22_int_df[which(A22_int_df$colony == "Ar"), "opt.exp"], alternative = "two.sided", paired = TRUE, conf.int = TRUE)

# list of transcripts that are 'Intermediate' expressed in Ar
Ar_int_transcripts <- responsive.transcripts.type[which(responsive.transcripts.type$colony == "Ar" & responsive.transcripts.type$exp_type == "Intermediate"), "Transcript"]
Ar_int_df <- responsive.transcripts.type[which(responsive.transcripts.type$Transcript %in% Ar_int_transcripts), ]

# Wilcoxon signed rank-test
wilcox.test(Ar_int_df[which(Ar_int_df$colony == "A22"), "opt.exp"],  Ar_int_df[which(Ar_int_df$colony == "Ar"), "opt.exp"], alternative = "two.sided", paired = TRUE, conf.int = TRUE)
```

As expected, for "Intermediate" expressed transcripts there is no difference in expression at 19.25C between colonies.  


### Thermal tolerance indicated by region of constant gene expression ###

The 'Intermediate' expressed transcripts are core molecular processes that are expressed at non-stressful temperatures, and shut-off when the organism experiences thermall stress. We hypothesized that if the more southern *Ar* colony was more thermally-tolerant than *A22*, transcripts with 'Intermediate' expression (10-30C) would be active across a wider range of temperatures. To test this with our data, we calculated the standard deviation of the expression function for each temperature transcript that was 'Intermediate' expressed in each colony.

```{r calc_Intermediate_variance}
# extract 'Intermediate' expressed transcripts for A22 colony
setkey(TPM.dt.sub, Transcript)
A22trlist <- A22.interaction.transcripts.type[which(A22.interaction.transcripts.type$exp_type == "Intermediate"), "Transcript"]
A22.TPM.int.dt <- TPM.dt.sub[A22trlist]
setkey(A22.TPM.int.dt, colony)
A22.TPM.int.dt <- A22.TPM.int.dt["A22"]
str(A22.TPM.int.dt)

# calculate standard deviation of expression for each transcript
A22_int_sd <- ddply(A22.TPM.int.dt, .(Transcript), RxNsd.concave)

# repeat for Ar
Artrlist <- Ar.interaction.transcripts.type[which(Ar.interaction.transcripts.type$exp_type == "Intermediate"), "Transcript"]
Ar.TPM.int.dt <- TPM.dt.sub[Artrlist]
setkey(Ar.TPM.int.dt, colony)
Ar.TPM.int.dt <- Ar.TPM.int.dt["Ar"]
str(Ar.TPM.int.dt)

Ar_int_sd <- ddply(Ar.TPM.int.dt, .(Transcript), RxNsd.concave)
```

With these values calculated, I compare the standard deviation of expression between colonies.

```{r compare_Intermediate_variance}
# T-test
t.test(A22_int_sd$exp_sd, Ar_int_sd$exp_sd)

# Plot
# prep data
A22_int_var$colony <- "A22"
Ar_int_var$colony <- "Ar"
comb_int_var <- rbind(A22_int_var, Ar_int_var)
# ggplot
g1 <- ggplot(comb_int_var, aes(x=exp_sd, fill=colony)) + geom_density(alpha=0.2, position="identity")
g1 + scale_y_continuous(name="Density") +
  scale_x_continuous(name=expression("Standard deviation of expression"))
```

Consistent with our hypothesis, 'Intermediate' transcripts in *Ar* are expressed over a significantly wider range of temperatures than in *A22*. 

### Thermal sensitivity indicated by response of bimodally-expressed transcripts ###

As the converse of the above hypothesis, a colony that is especially thermally-sensitive is likely to activate expression of molecular processes more quickly. We tested this using the same approach as for the 'Intermediate' transcripts, but using the inverse of the 'Bimodal' expressed transcripts. 


```{r calc_Bimodal_variance}
# extract 'Bimodal' expressed transcripts for A22 colony
A22trlist.bim <- A22.interaction.transcripts.type[which(A22.interaction.transcripts.type$exp_type == "Bimodal"), "Transcript"]
A22.TPM.bim.dt <- TPM.dt.sub[A22trlist.bim]
setkey(A22.TPM.bim.dt, colony)
A22.TPM.bim.dt <- A22.TPM.bim.dt["A22"]
str(A22.TPM.bim.dt)

# calculate standard deviation of expression for each transcript
A22_bim_sd <- ddply(A22.TPM.bim.dt, .(Transcript), RxNsd.convex)

# repeat for Ar
Artrlist.bim <- Ar.interaction.transcripts.type[which(Ar.interaction.transcripts.type$exp_type == "Bimodal"), "Transcript"]
Ar.TPM.bim.dt <- TPM.dt.sub[Artrlist.bim]
setkey(Ar.TPM.bim.dt, colony)
Ar.TPM.bim.dt <- Ar.TPM.bim.dt["Ar"]
str(Ar.TPM.bim.dt)

Ar_bim_sd <- ddply(Ar.TPM.bim.dt, .(Transcript), RxNsd.convex)
```

Next, I compare the standard deviations of expression for each transcipt between colonies.

```{r compare_Intermediate_variance}
# t-test
t.test(A22_bim_sd$exp_sd, Ar_bim_sd$exp_sd)

# Plot
# prep data
A22_bim_var$colony <- "A22"
Ar_bim_var$colony <- "Ar"
comb_bim_var <- rbind(A22_bim_var, Ar_bim_var)
# ggplot
g2 <- ggplot(comb_bim_var, aes(x=exp_sd, fill=colony)) + geom_density(alpha=0.2, position="identity")
g2 + scale_y_continuous(name="Density") +
  scale_x_continuous(name=expression("Standard deviation of expression function"))
```

Both the T-test and plot show that there is no difference in the standard deviation of expression for bimodally-expressed transcripts between colonies.

### Compare peak expression among colonies ###

Cumulative distribution function of peak expression for transcripts that differ in expression between *A22* and *Ar*

```{r max_exp_CDF}
png(paste(resultsdir, "CDF_expression_all.png", sep=""))
g3 <- ggplot(responsive.transcripts.type, aes(x=max.val, fill=colony)) + geom_density(alpha=0.2, position="identity")
g3 + scale_y_continuous(name="Density") +
  scale_x_continuous(name="Temperature of maximum expression")
dev.off()


# merge data.tables of transcripts with colony x temperature interaction
interaction.transcripts.type <- rbind(A22.interaction.transcripts.type, Ar.interaction.transcripts.type)
png(paste(resultsdir, "CDF_expression_interaction.png", sep=""))
g4 <- ggplot(interaction.transcripts.type, aes(x=max.val, fill=colony)) + geom_density(alpha=0.2, position="identity")
g4 + scale_y_continuous(name="Density") +
  scale_x_continuous(name="Temperature of maximum expression")
dev.off()

# faceted by type
png(paste(resultsdir, "CDF_expression_intermediate_interaction.png", sep=""))
g5 <- ggplot(interaction.transcripts.type, aes(x=max.val, group=colony)) + geom_density(alpha=0.2, position="identity")
g5 + facet_grid(. ~ exp_type) + scale_y_continuous(name="Density") +
  scale_x_continuous(name="Temperature of maximum expression")
dev.off()
```



## Gene set enrichment analysis ##

I use [topGO](http://www.bioconductor.org/packages/2.12/bioc/html/topGO.html) to perform gene set enrichment analysis (GSEA) seperately for each expression type (bimodal, intermediate, high, low).

First need to create gene ID to GO term map file

```{r geneid2go, echo=TRUE, eval=TRUE, cache=TRUE}
# create geneid2go.map file from FastAnnotator AnnotationTable.txt
geneid2GOmap(annotationfile)
```

then read map file.

```{r readmap, echo=TRUE, eval=TRUE}
# read mappings file
geneID2GO <- readMappings(file = "geneid2go.map")
str(head(geneID2GO))
```

### GSEA for thermally-responsive transcripts ###

Using this gene2GO map file, perform GSEA for:

**1) all responsive transcripts**

Use `selectFDR` function to select transcripts with adjusted P < 0.05.

```{r gsea_all}
# create geneList. note that NA values cause problems with topGO
# so set any NA to 1 as need to retain for GO analysis
Ap.geneList <- RxNout$padj
Ap.geneList[which(is.na(Ap.geneList))] <- 1
stopifnot(length(which(is.na(Ap.geneList))) == 0)
names(Ap.geneList) <- RxNout$Transcript
str(Ap.geneList)

# Function to select top genes (defined above)
selectFDR <- function(padj) {
    return(padj < 0.05)
}

# create topGOdata object
Ap.BP.GOdata <- new("topGOdata",
                 description = "BP gene set analysis", ontology = "BP",
                 allGenes = Ap.geneList, geneSel = selectFDR,
                 nodeSize = 10,
                 annot = annFUN.gene2GO, gene2GO = geneID2GO)

Ap.BP.GOdata

# perform enrichment analysis using parentchild method
Ap.BP.resultParentChild <- runTest(Ap.BP.GOdata, statistic = 'fisher', algorithm = 'parentchild')
Ap.BP.resultParentChild

# table results
Ap.BP.ResTable <- GenTable(Ap.BP.GOdata, parentchild = Ap.BP.resultParentChild, topNodes = 118)
#Ap.BP.ResTable
write.table(Ap.BP.ResTable, file = paste(resultsdir, "Ap_GO.BP_results.txt", sep=""), quote=FALSE, row.names=FALSE, sep = "\t")
pandoc.table(Ap.BP.ResTable)

# graph significant nodes

pdf(paste(resultsdir, "Ap.BP_topGO_sig_nodes.pdf", sep=""))
showSigOfNodes(Ap.BP.GOdata, score(Ap.BP.resultParentChild), firstSigNodes = 10, useInfo = 'all')
dev.off()
```

**2) High and low expressed transcripts**

Use `selectTranscript` function to select transcripts based on 'exp_type'. As only significant transcripts have an 'exp_type' assigned, this is a small subset of the above.

```{r exp_type_function}
selectTranscript <- function(score) {
    return(score == 1)
}

# To select genes, add 'exp_type' to RxN df
RxNout.t <- merge(RxNout, Ap.exp_type, by="Transcript", all=TRUE)
length(which(!is.na(RxNout.t$exp_type)))
```


```{r bim.gsea, echo=TRUE, eval=TRUE}
# create geneList
Ap.bim.geneList <- rep(0, length = nrow(RxNout.t))
Ap.bim.geneList[which(RxNout.t$exp_type=="Bimodal")] <- 1
names(Ap.bim.geneList) <- RxNout.t$Transcript
str(Ap.bim.geneList)
table(Ap.bim.geneList)

# create topGOdata object
Ap.bim.BP.GOdata <- new("topGOdata",
                 description = "BP gene set analysis",
                 ontology = "BP",
                 allGenes = Ap.bim.geneList,
                 geneSel = selectTranscript,
                 nodeSize = 10,
                 annot = annFUN.gene2GO,
                 gene2GO = geneID2GO)

Ap.bim.BP.GOdata

# perform enrichment analysis using parentchild method
Ap.bim.BP.resultParentChild <- runTest(Ap.bim.BP.GOdata, statistic = 'fisher', algorithm = 'parentchild')
Ap.bim.BP.resultParentChild
```

Enriched gene sets for genes expressed at both high and low temperatures.

```{r, echo=FALSE, results="asis"}
Ap.bim.BP.ResTable <- GenTable(Ap.bim.BP.GOdata, parentchild = Ap.bim.BP.resultParentChild, topNodes = 52)
#Ap.bim.BP.ResTable
write.table(Ap.bim.BP.ResTable, file = paste(resultsdir, "Ap_bimodal_GO.BP_results.txt", sep=""), quote=FALSE, row.names=FALSE, sep = "\t")
pandoc.table(Ap.bim.BP.ResTable)
```


**3) Intermediate-temperature expressed transcripts**

```{r int.gsea, echo=TRUE, eval=TRUE}
# create geneList
Ap.int.geneList <- rep(0, length = nrow(RxNout.t))
Ap.int.geneList[which(RxNout.t$exp_type=="Intermediate")] <- 1
names(Ap.int.geneList) <- RxNout.t$Transcript
str(Ap.int.geneList)
table(Ap.int.geneList)

# create topGOdata object
Ap.int.BP.GOdata <- new("topGOdata",
                 description = "BP gene set analysis",
                 ontology = "BP",
                 allGenes = Ap.int.geneList,
                 geneSel = selectTranscript,
                 nodeSize = 10,
                 annot = annFUN.gene2GO,
                 gene2GO = geneID2GO)

Ap.int.BP.GOdata

# perform enrichment analysis using parentchild method
Ap.int.BP.resultParentChild <- runTest(Ap.int.BP.GOdata, statistic = 'fisher', algorithm = 'parentchild')
Ap.int.BP.resultParentChild
```

Enriched gene sets for genes expressed at intermediate temperatures.

```{r, echo=FALSE, results="asis"}
Ap.int.BP.ResTable <- GenTable(Ap.int.BP.GOdata, parentchild = Ap.int.BP.resultParentChild, topNodes=16)
Ap.int.BP.ResTable
write.table(Ap.int.BP.ResTable, file = paste(resultsdir, "Ap_intermediate_GO.BP_results.txt", sep=""), quote=FALSE, row.names=FALSE, sep = "\t")
pandoc.table(Ap.int.BP.ResTable)
```


**4) High temperature expressed transcripts**


```{r hig.gsea, echo=TRUE, eval=TRUE}
# create geneList
Ap.hig.geneList <- rep(0, length = nrow(RxNout.t))
Ap.hig.geneList[which(RxNout.t$exp_type=="High")] <- 1
names(Ap.hig.geneList) <- RxNout.t$Transcript
str(Ap.hig.geneList)
table(Ap.hig.geneList)

# create topGOdata object
Ap.hig.BP.GOdata <- new("topGOdata",
                 description = "BP gene set analysis",
                 ontology = "BP",
                 allGenes = Ap.hig.geneList,
                 geneSel = selectTranscript,
                 nodeSize = 10,
                 annot = annFUN.gene2GO,
                 gene2GO = geneID2GO)

Ap.hig.BP.GOdata

# perform enrichment analysis using parentchild method
Ap.hig.BP.resultParentChild <- runTest(Ap.hig.BP.GOdata, statistic = 'fisher', algorithm = 'parentchild')
Ap.hig.BP.resultParentChild
```

Enriched gene sets for genes expressed at both high temperatures only.

```{r, echo=FALSE, results="asis"}
Ap.hig.BP.ResTable <- GenTable(Ap.hig.BP.GOdata, parentchild = Ap.hig.BP.resultParentChild, topNodes=12)
#Ap.hig.BP.ResTable
write.table(Ap.hig.BP.ResTable, file = paste(resultsdir, "Ap_high_GO.BP_results.txt", sep=""), quote=FALSE, row.names=FALSE, sep = "\t")
pandoc.table(Ap.hig.BP.ResTable)
```


**5) Low temperature expressed transcripts**

```{r low.gsea, echo=TRUE, eval=TRUE}
# create geneList
Ap.low.geneList <- rep(0, length = nrow(RxNout.t))
Ap.low.geneList[which(RxNout.t$exp_type=="Low")] <- 1
names(Ap.low.geneList) <- RxNout.t$Transcript
str(Ap.low.geneList)
table(Ap.low.geneList)

# create topGOdata object
Ap.low.BP.GOdata <- new("topGOdata",
                 description = "BP gene set analysis",
                 ontology = "BP",
                 allGenes = Ap.low.geneList,
                 geneSel = selectTranscript,
                 nodeSize = 10,
                 annot = annFUN.gene2GO,
                 gene2GO = geneID2GO)

Ap.low.BP.GOdata

# perform enrichment analysis using parentchild method
Ap.low.BP.resultParentChild <- runTest(Ap.low.BP.GOdata, statistic = 'fisher', algorithm = 'parentchild')
Ap.low.BP.resultParentChild
```

Enriched gene sets for genes expressed at low temperatures only.

```{r, echo=FALSE, results="asis"}
Ap.low.BP.ResTable <- GenTable(Ap.low.BP.GOdata, parentchild = Ap.low.BP.resultParentChild, topNodes=26)
Ap.low.BP.ResTable
write.table(Ap.low.BP.ResTable, file = paste(resultsdir, "Ap_low_GO.BP_results.txt", sep=""), quote=FALSE, row.names=FALSE, sep = "\t")
pandoc.table(Ap.low.BP.ResTable)
```

```{r, echo=FALSE}
# graph significant nodes
pdf(paste(resultsdir, "Ap_bimodal_BP_topGO_sig_nodes.pdf", sep=""))
showSigOfNodes(Ap.bim.BP.GOdata, score(Ap.bim.BP.resultParentChild), firstSigNodes = 52, useInfo = 'all')
dev.off()

pdf(paste(resultsdir, "Ap_intermediate_BP_topGO_sig_nodes.pdf", sep=""))
showSigOfNodes(Ap.int.BP.GOdata, score(Ap.int.BP.resultParentChild), firstSigNodes = 16, useInfo = 'all')
dev.off()

pdf(paste(resultsdir, "Ap_high_BP_topGO_sig_nodes.pdf", sep=""))
showSigOfNodes(Ap.hig.BP.GOdata, score(Ap.hig.BP.resultParentChild), firstSigNodes = 12, useInfo = 'all')
dev.off()

pdf(paste(resultsdir, "Ap_low_BP_topGO_sig_nodes.pdf", sep=""))
showSigOfNodes(Ap.low.BP.GOdata, score(Ap.low.BP.resultParentChild), firstSigNodes = 26, useInfo = 'all')
dev.off()
```

Visualize differens in GO terms among expression types using a wordcloud.

```{gsea_wordcloud, cache=TRUE}
# create Corpus for text mining
GO.dfs <- c(paste(Ap.low.BP.ResTable$Term, collapse=" "), paste(Ap.hig.BP.ResTable$Term, collapse=" "),
            paste(Ap.int.BP.ResTable$Term, collapse=" "), paste(Ap.bim.BP.ResTable$Term, collapse=" "))

vs <- VectorSource(GO.dfs)
GO.corp <- Corpus(vs)
GO.corp

GO.corp <- tm_map(GO.corp, removePunctuation)

# create matrix of terms
term.matrix <- TermDocumentMatrix(GO.corp)
term.matrix <- as.matrix(term.matrix)
colnames(term.matrix) <- c('low', 'high', 'intermediate', 'bimodal')

# comparison cloud
comparison.cloud(term.matrix, max.words=200, random.order=FALSE, scale=c(0.25, 0.5))
```


## Comparison of expression patterns between colonies

A set of `r nrow(interaction.transcripts)` transcripts have expression patterns that depend on colony. In this section, I examine how these transcripts differ between colonies. Specifically, I expect genes that are up-regulated at high temperatures in the northern *A22* colony to be at constitutively higher expression in the more southern *Ar* colony. Conversely, I will examine the extent to which genes upregulated at colder temperatures in the *Ar* colony are constitutively expressed in the *A22* colony.








## Visualize responsive transcripts

Make plots for all significant transcripts

```{r plot_responsive, echo=FALSE, eval=FALSE, cache=TRUE}
# Line plot, expression against temp, faceted by colony
p1 <- ggplot(temperature.transcripts.TPM, aes(x=val, y=exp.scaled, group=Transcript)) +
  geom_line() +
  facet_grid(. ~ colony) +
  scale_y_continuous(name="Expression (scaled)") +
  scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
p1


# Smooth plot, expression against temp, faceted by colony
p2 <- ggplot(temperature.transcripts.TPM, aes(x=val, y=exp.scaled, group=Transcript)) +
  geom_smooth() +
  facet_grid(. ~ colony) +
  scale_y_continuous(name="Expression (scaled)") +
  scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
p2

# Same as p1, faceted by expression type
p3 <- ggplot(temperature.transcripts.TPM, aes(x=val, y=exp.scaled, group=Transcript)) +
  geom_line() +
  facet_grid(exp_type ~ colony) +
  scale_y_continuous(name="Expression (scaled)") +
  scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
p3

# Smooth plot, expression against temp, faceted by colony
p4 <- ggplot(temperature.transcripts.TPM, aes(x=val, y=exp.scaled, group=Transcript)) +
  geom_smooth() +
  facet_grid(exp_type ~ colony) +
  scale_y_continuous(name="Expression (scaled)") +
  scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
p4
```

Make plots for transcripts with significant temperature by colony interaction

```{r plot_interaction_responsive, echo=FALSE, eval=FALSE, cache=TRUE}
# Line plot, expression against temp, faceted by colony
p1 <- ggplot(temperature.transcripts.TPM.interaction, aes(x=val, y=exp.scaled, group=Transcript)) +
  geom_line() +
  facet_grid(. ~ colony) +
  scale_y_continuous(name="Expression (scaled)") +
  scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
p1


# Smooth plot, expression against temp, faceted by colony
p2 <- ggplot(temperature.transcripts.TPM.interaction, aes(x=val, y=exp.scaled, group=Transcript)) +
  geom_smooth() +
  facet_grid(. ~ colony) +
  scale_y_continuous(name="Expression (scaled)") +
  scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
p2

# Same as p1, faceted by expression type
p3 <- ggplot(temperature.transcripts.TPM.interaction, aes(x=val, y=exp.scaled, group=Transcript)) +
  geom_line() +
  facet_grid(exp_type ~ colony) +
  scale_y_continuous(name="Expression (scaled)") +
  scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
p3

# Smooth plot, expression against temp, faceted by colony
p4 <- ggplot(temperature.transcripts.TPM.interaction, aes(x=val, y=exp.scaled, group=Transcript)) +
  geom_smooth() +
  facet_grid(exp_type ~ colony) +
  scale_y_continuous(name="Expression (scaled)") +
  scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
p4
```



```{r plot, echo=FALSE, eval=FALSE, cache=TRUE}
# Line plot, expression against temp, faceted by colony
png(paste(resultsdir, "Ap_expression_by_colony_line.png", sep=""))
  p1 <- ggplot(temperature.transcripts.TPM, aes(x=val, y=exp.scaled, group=Transcript)) +
    geom_line() +
    facet_grid(. ~ colony) +
    scale_y_continuous(name="Expression (scaled)") +
    scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
  p1
dev.off()

# Smooth plot, expression against temp, faceted by colony
png(paste(resultsdir, "Ap_expression_by_colony_smooth.png", sep=""))
  p2 <- ggplot(temperature.transcripts.TPM, aes(x=val, y=exp.scaled, group=Transcript)) +
    geom_smooth() +
    facet_grid(. ~ colony) +
    scale_y_continuous(name="Expression (scaled)") +
    scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
  p2
dev.off()

# Same as p1, faceted by expression type
png(paste(resultsdir, "Ap_expression_by_colony_exp_line.png", sep=""))
  p3 <- ggplot(temperature.transcripts.TPM, aes(x=val, y=exp.scaled, group=Transcript)) +
    geom_line() +
    facet_grid(exp_type ~ colony) +
    scale_y_continuous(name="Expression (scaled)") +
    scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
  p3
dev.off()

# Smooth plot, expression against temp, faceted by colony
png(paste(resultsdir, "Ap_expression_by_colony_exp_smooth.png", sep=""))
  p4 <- ggplot(temperature.transcripts.TPM, aes(x=val, y=exp.scaled, group=Transcript)) +
    geom_smooth() +
    facet_grid(exp_type ~ colony) +
    scale_y_continuous(name="Expression (scaled)") +
    scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
  p4
dev.off()

```


```{r plot_interaction_responsive_to_file, echo=FALSE, eval=FALSE, cache=TRUE}
# Line plot, expression against temp, faceted by colony
png(paste(resultsdir, "Ap_expression_interaction_by_colony_line.png", sep=""))
  p1 <- ggplot(temperature.transcripts.TPM.interaction, aes(x=val, y=exp.scaled, group=Transcript)) +
    geom_line() +
    facet_grid(. ~ colony) +
    scale_y_continuous(name="Expression (scaled)") +
    scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
  p1
dev.off()

# Smooth plot, expression against temp, faceted by colony
png(paste(resultsdir, "Ap_expression_interaction_by_colony_smooth.png", sep=""))
  p2 <- ggplot(temperature.transcripts.TPM.interaction, aes(x=val, y=exp.scaled, group=Transcript)) +
    geom_smooth() +
    facet_grid(. ~ colony) +
    scale_y_continuous(name="Expression (scaled)") +
    scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
  p2
dev.off()

# Same as p1, faceted by expression type
png(paste(resultsdir, "Ap_expression_interaction_by_colony_exp_line.png", sep=""))
  p3 <- ggplot(temperature.transcripts.TPM.interaction, aes(x=val, y=exp.scaled, group=Transcript)) +
    geom_line() +
    facet_grid(exp_type ~ colony) +
    scale_y_continuous(name="Expression (scaled)") +
    scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
  p3
dev.off()

# Smooth plot, expression against temp, faceted by colony
png(paste(resultsdir, "Ap_expression_interaction_by_colony_exp_smooth.png", sep=""))
  p4 <- ggplot(temperature.transcripts.TPM.interaction, aes(x=val, y=exp.scaled, group=Transcript)) +
    geom_smooth() +
    facet_grid(exp_type ~ colony) +
    scale_y_continuous(name="Expression (scaled)") +
    scale_x_continuous(name=expression(paste("Temperature ", degree, "C")))
  p4
dev.off()
```


## Session information ##

```{r session}
save.image()
sessionInfo()
```

## References

```{r references, results='asis'}
bibliography()
```
